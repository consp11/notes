Ошибка:
	На странице секундомера нужно было сделать функцию, которая сбрасывает секундомер в списке секундомеров вниз списка или поднимает вверх списка.
	За основу была взята функция, которая поднимает секундомер в списке на 1 позицию
	Эта функция была реализована через обмен элементами между соседними позициями.
	Аналогично, был реализован обмен элементами: нижний элемент ставился на место текущего, а текущий - на место нижнего. Однако, в данном случае, это поведение было неверным (т.к. нижний элемент должен был стать вторым с низу)
	Ошибка заимствовала поведение, которое допустимо для одной реализации, но недопустимо для другой реализации
	При этом копирование также шло из-за того, что функция поиска id секундомера не была реализована отдельно: в результате, собственно, был соблазн её скопировать.

Методы предотвращения:
	1. Все методы должны делаться с нуля (но это может привести к проблемам с ошибками)
	2. По-возможности, простейшие операции, всё-таки, должны быть вынесены в отдельно реализованные повторно используемые функции
	3. Должно быть заранее расписано подробно, как и что делается. В идеале, составлена формальная модель, в которой расписаны все значимые элементы этой модели (значимые параметры, такие как последовательность секундомеров).
	4. По модели или просто так можно спроектировать тесты в письменном виде, а потом уже делать их реально.
	При этом, чтобы проект не мешал тестированию, сначала можно протестировать просто так, а потом уже составлять проект.

Реальное решение:
	Ошибка найдена случайно при эксплуатации в тот же день. Ущерба нет, локализация и исправления - простые.


Ошибка:
	В просмотренном цикле метода Keccak_Output_512 (\vinkekfish\keccak\keccak-abstract.cs) была доказана его завершаемость. Действительно, он всегда завершается.
	Однако, не было доказано, что он завершается именно на столько, на сколько длинен output
	Из-за того, что была забыта команда len--, цикл всегда записывал порядка 200 байтов, вместо 64-х, из-за чего программа терпела краш.

Методы предотвращения:
	Хрен знает. Более формально всё писать. Отдыхать лучше, видимо, был уставший и не обратил пристальное внимание на каждую строку кода.

Реальное решение:
	Ошибка найдена при тестах в тот же день. Локализация заняла очень приличное время (несколько часов)


Ошибка:
	В классе KeccakStatesArray (\vinkekfish\keccak\keccak-abstract.cs) статическое проверочное поле CountToCheck записывалось без Interlocked, поэтому при многопоточных тестах показывало ненулевой результат.
	В результате после тестов был дисбаланс около 1800 (причём он повторялся из теста в тест точно несколько раз).

Методы предотвращения:
	Учитывать, что даже потоконебезопасные классы иногда должны иметь потокобезопасные статические поля

Реальное решение:
	Ошибка найдена при тестах. После изменения кода (перенёс декремент выше) догадался. Заняло вряд ли большще 15-ти минут.
